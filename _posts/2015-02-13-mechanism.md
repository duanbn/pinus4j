---
layout: default
---

# 框架机制

## 数据库水平切分模型

Pinus 的水平切分模型分为几个层级，这个层级关系被配置在 `storage-config.xml` 文件中，配置文件中的节点名称为 cluster。cluster 可以配置多个，具体请参考 [入门教程]({% post_url 2015-02-13-induction %}) 中的配置文件信息。水平切分模型如下图所示：

![]({{site.baseurl}}/img/sharding_arch.png)

* __ShardingKey__：分片因子。数据的增、删、改都需要通过这个因子来定位最终会存储在哪个库的哪张表中，ShardingKey 的值在路由选择时会变成一个数字，如果是字符串也会通过 hash 算法变成一个数字。

* __cluster__：表示一个数据库集群，每个集群在配置的时候需要指定一个集群名称。

* __region__：表示一个数据库分组，每个 region 需要指定一个数字的范围，这个数值表示可以接受的 ShardingKey 的值的范围。这里需要注意的是，这个范围不是指具体的记录数，而是可以接受的 ShardingKey 的值。

* __sharding__：表示一个分片库。

* __sharding table__：表示一个分片库中的一个分表。

* __global__：表示一个全局库。在一个集群当中只能存在一个全局库，全局库中的数据不会被切分。

* __global table__：表示全局库中的表。

了解到以上概念之后，下边描述一下具体的工作机制。

首先在定义数据实体对象的时候，我们需要对实体对象类使用 `@Table` 进行注解，@Table 注解中有 shardingBy、shardingNum、cluster 等属性。这些属性表示该数据实体属于哪个集群以及 ShardingKey 的值依据哪个字段的值产生。当我们调用 save 方法保存这个对象时，Pinus 会首先给这个对象生成一个集群中唯一的主键（参考下一节：集群中数据主键生成），然后根据 shardingBy 所设定的字段取出值之后创建 ShardingKey 对象，DBRouter 实例会根据给定的 ShardingKey 找到对应的一个数据库资源，然后将数据对象映射成 SQL 语句。

## 数据扩容

Pinus 目前只支持静态扩容，扩容的方式是依靠添加新的 region 来完成。结合上述概念，每个 region 由一组库组成，当某个集群的数据需要扩容时只需要添加新的 region 即可。

## 缓存机制

Pinus 的缓存目前基于 memcached 实现，用户可以通过实现 IPrimaryCache 和 ISecondCache 接口进行扩展。

* ### 一级缓存

与数据库中的一条记录一一对应，增、删、改、查操作会处理缓存与数据库的一致性，全局库中数据的缓存与分片库中数据缓存的 key 值不同，但都是基于数据主键生成。

命中机制，当使用主键进行查询时会首先查询缓存，如果命中则直接返回；如果根据条件进行查询时，会首先根据查询条件从数据库中取出主键，之后从缓存中获取数据；如果部分主键没有命中缓存，则再将没有命中的主键通过 in 查询从数据库中查询，之后再将数据放入缓存中。

* ### 二级缓存

对 IQuery 查询结果进行缓存，当增、删、改操作影响到缓存时，Pinus 会将缓存结果清除，缓存中的 key 是将 IQuery 对象通过 hash 操作生成唯一的字符串作为 key。

命中机制，将新查询的 IQuery 通过相同的 hash 操作生成 key，然后去缓存中查询，如果命中则直接返回，如果没有命中则查询数据库，将结果集进行缓存。

## 集群中数据主键生成

由于数据进行了水平切分，使用基于单表的主键自增方式就会出现问题。例如：某个实体 A 被分了 10 张表，那么有可能会有 10 个相同记录的主键，此时实体 B 在依靠 A 的主键进行切分时就会出现问题。

为了避免上述情况的发生，每个表记录的主键生成都需要交给一个单独的服务来处理，Pinus 选择了使用基于 zookeeper 服务来生成主键，之所以选择 zookeeper 是出于以下几点考虑：

* 其主要作用就是为了协调分布式系统、包括分布式存储，因此为分布式系统提供了很多特性；
* 自身就是分布式的，容灾能力较强；
* 性能非常好，读写速度很快；
* 非常轻量，非常适合 Pinus 的使用场景。

其实网上也有很多其他的方式来生成主键。

## 生成主键的机制
在 zookeeper 中创建集群目录，集群目录中保存和表明相同的文件，每个文件的内容就是最后生成主键的数值。

## 事务机制

Pinus 的事务涉及到多个数据库资源，因此属于分布式事务的范畴，但是需要特别说明的是，分布式事务是一种 share everything 的思想，分布式事务相关是一个非常广泛的话题，这里就不展开讨论，Pinus 没有使用 2pc 或者 3pc 来实现分布式事务，使用的是 Best Efforts 1PC 的方式来实现了 JTA 接口。
